package io.keyko.monitoring.stream;

import io.keyko.monitoring.model.AccountCreatedAggregation;
import io.keyko.monitoring.time.EventBlockTimestampExtractor;
import io.keyko.monitoring.windows.DailyTimeWindows;
import net.consensys.eventeum.BlockEvent;
import net.consensys.eventeum.ContractEvent;
import net.consensys.eventeum.EventBlock;
import net.consensys.eventeum.NumberParameter;
import net.consensys.eventeum.StringParameter;
import org.apache.kafka.common.serialization.Serde;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.common.utils.Bytes;
import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.kstream.*;
import org.apache.kafka.streams.state.WindowStore;

import java.time.Duration;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.util.List;

import static org.apache.kafka.streams.kstream.Suppressed.BufferConfig.unbounded;

public class EventProcessor {

  /**
   * Filter the events that has been already confirmed.
   *
   * @param contractEvents KStream with the event from the topic contract-events generated by Eventeum
   * @return KStream with the events that have been confirmed.
   */
  public KStream<String, ContractEvent> filterConfirmed(KStream<String, ContractEvent> contractEvents) {
    return contractEvents
      .filter((key, event) -> event.getDetails().getStatus().toString().equalsIgnoreCase("CONFIRMED"));
  }

  /**
   * Sending confirmed events to a topic corresponding with the name of the event.
   *
   * @param confirmedEvents Stream with the confirmed events
   */
  public void splitTopics(KStream<String, EventBlock> confirmedEvents, Serde<EventBlock> eventBlockAvroSerde) {
    confirmedEvents.to((key, value, recordContext) ->
        value.getDetails().getName().toLowerCase(),
      Produced.with(Serdes.String(), eventBlockAvroSerde)
    );
  }

  /**
   * Join the events with the corresponding block to track the timestamp of mining.
   *
   * @param eventAvroStream Stream with the confirmed events
   * @param blockAvroStream Table with the blocks
   * @return KStream
   */
  public KStream<String, EventBlock> joinEventWithBlock(KStream<String, ContractEvent> eventAvroStream, KTable<String, BlockEvent> blockAvroStream,
                                                        Serde<ContractEvent> eventAvroSerde, Serde<BlockEvent> blockAvroSerde) {
    return eventAvroStream
      .selectKey((key, event) -> event.getDetails().getBlockHash())
      .join(blockAvroStream,
        (event, block) -> {
          EventBlock eventblock = new EventBlock();

          eventblock.setDetails(event.getDetails());
          eventblock.setDetailsBlock(block.getDetails());
          eventblock.setId(event.getId());
          eventblock.setRetries(event.getRetries());
          eventblock.setType(event.getType());

          return eventblock;
        },
        Joined.with(Serdes.String(), eventAvroSerde, blockAvroSerde)
      )
      .selectKey((key, event) -> event.getId());
  }


  /**
   * Aggregate accounts created events using a daily window
   *
   * @param topicsToAggregate
   * @param builder
   * @param eventBlockAvroSerde
   * @return
   */
  public KStream<String, AccountCreatedAggregation> accountDailyAggregation(List<String> topicsToAggregate, StreamsBuilder builder, Serde<EventBlock> eventBlockAvroSerde) {

    final int windowStartHour = 0;
    final ZoneId zone = ZoneOffset.UTC;
    final Duration gracePeriod = Duration.ofMinutes(60L);

    List<String> accountsTopics = topicsToAggregate;//, "VoteSignerAuthorized".toLowerCase(), "AttestationSignerAuthorized".toLowerCase());

    KStream<String, EventBlock> accountsCreatedStream = builder.stream(accountsTopics,
      Consumed.with(Serdes.String(), eventBlockAvroSerde)
        .withTimestampExtractor(new EventBlockTimestampExtractor()));

    KTable<Windowed<String>, Long> accountsCreatedDayTable =
      accountsCreatedStream
        .selectKey((key, event) -> event.getDetails().getName())
        .groupByKey(Grouped.with(Serdes.String(), eventBlockAvroSerde))
        .windowedBy(new DailyTimeWindows(zone, windowStartHour, gracePeriod))
        // .windowedBy(TimeWindows.of(Duration.ofSeconds(10)))
        .count(Materialized.<String, Long, WindowStore<Bytes, byte[]>>with(Serdes.String(), Serdes.Long())
          // the default store retention time is 1 day;
          // need to explicitly increase the retention time
          // to allow for a 1-day window plus configured grace period
          .withRetention(Duration.ofDays(1L).plus(gracePeriod)))
        // emits the final count when the window is closed.
        .suppress(Suppressed.untilWindowCloses(unbounded()));
    ;

    return formatAccountCreatedAggregation(accountsCreatedDayTable, zone);

  }


  /**
   * Transforms a Windowed Aggregation Table in a Stream of formatted data
   *
   * @param accountsCreatedDayTable
   * @param zone
   * @return
   */
  private KStream<String, AccountCreatedAggregation> formatAccountCreatedAggregation(KTable<Windowed<String>, Long> accountsCreatedDayTable, ZoneId zone) {

    return accountsCreatedDayTable
      .toStream()
      .map((windowed, count) -> {

        AccountCreatedAggregation accountCreatedAggregation = new AccountCreatedAggregation(
          windowed.window().startTime().atZone(zone),
          count,
          windowed.key()

        );

        //DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy - HH:mm:ss Z");
        //String formattedString = windowed.window().startTime().atZone(ZoneOffset.UTC).format(formatter);

        //String key = windowed.key().concat("-").concat(formattedString);

        String key = windowed.key().concat("-").concat(accountCreatedAggregation.getDate());
        return KeyValue.pair(key, accountCreatedAggregation);

      });

  }

  public void alertNoEpochRewardsDistributed(StreamsBuilder builder, List<String> EpochRewardsDistributedToVoters, Serde<EventBlock> eventBlockAvroSerde) {
    builder.stream(EpochRewardsDistributedToVoters, Consumed.with(Serdes.String(), eventBlockAvroSerde))
      .filter((key, event) -> ((NumberParameter) event.getDetails().getNonIndexedParameters().get(0)).getValue().equals("0"))
      .foreach((x, y) -> System.out.println("NoEpochRewardsDistributed for group: " + ((StringParameter) y.getDetails().getIndexedParameters().get(0)).getValue()));
  }

}
