package io.keyko.monitoring.stream;

import io.keyko.monitoring.model.AccountCreatedAggregation;
import io.keyko.monitoring.time.EventBlockTimestampExtractor;
import io.keyko.monitoring.windows.DailyTimeWindows;
import net.consensys.eventeum.BlockEvent;
import net.consensys.eventeum.ContractEvent;
import net.consensys.eventeum.EventBlock;
import net.consensys.eventeum.StringParameter;
import org.apache.kafka.common.serialization.Serde;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.common.utils.Bytes;
import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.kstream.*;
import org.apache.kafka.streams.state.WindowStore;

import java.time.Duration;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.apache.kafka.streams.kstream.Suppressed.BufferConfig.unbounded;
import static org.apache.kafka.streams.kstream.Suppressed.untilWindowCloses;

public class EventProcessor {


  /**
   * Filter the events that has been already confirmed.
   *
   * @param contractEvents KStream with the event from the topic contract-events generated by Eventeum
   * @return KStream with the events that have been confirmed.
   */
  public KStream<String, ContractEvent> filterConfirmed(KStream<String, ContractEvent> contractEvents) {
    return contractEvents
      .filter((key, event) -> event.getDetails().getStatus().toString().equalsIgnoreCase("CONFIRMED"));
  }

  /**
   * Sending confirmed events to a topic corresponding with the name of the event.
   *
   * @param confirmedEvents Stream with the confirmed events
   */
  public void splitTopics(KStream<String, EventBlock> confirmedEvents, Serde<EventBlock> eventBlockAvroSerde) {
    confirmedEvents.to((key, value, recordContext) ->
        value.getDetails().getName().toLowerCase(),
      Produced.with(Serdes.String(), eventBlockAvroSerde)
    );
  }

  /**
   * Join the events with the corresponding block to track the timestamp of mining.
   *
   * @param eventAvroStream Stream with the confirmed events
   * @param blockAvroStream Table with the blocks
   * @return KStream
   */
  public KStream<String, EventBlock> joinEventWithBlock(KStream<String, ContractEvent> eventAvroStream, KTable<String, BlockEvent> blockAvroStream,
                                                        Serde<ContractEvent> eventAvroSerde, Serde<BlockEvent> blockAvroSerde) {
    return eventAvroStream
      .selectKey((key, event) -> event.getDetails().getBlockHash())
      .join(blockAvroStream,
        (event, block) -> {
          EventBlock eventblock = new EventBlock();

          eventblock.setDetails(event.getDetails());
          eventblock.setDetailsBlock(block.getDetails());
          eventblock.setId(event.getId());
          eventblock.setRetries(event.getRetries());
          eventblock.setType(event.getType());

          return eventblock;
        },
        Joined.with(Serdes.String(), eventAvroSerde, blockAvroSerde)
      )
      .selectKey((key, event) -> event.getId());
  }


  /**
   * Aggregate accounts created events using a daily window
   *
   * @param topicsToAggregate
   * @param builder
   * @param eventBlockAvroSerde
   * @return
   */
  public KStream<String, AccountCreatedAggregation> accountDailyAggregation(List<String> topicsToAggregate, StreamsBuilder builder, Serde<EventBlock> eventBlockAvroSerde) {

    final int windowStartHour = 0;
    final ZoneId zone = ZoneOffset.UTC;
    final Duration gracePeriod = Duration.ofMinutes(60L);

    List<String> accountsTopics = topicsToAggregate;//, "VoteSignerAuthorized".toLowerCase(), "AttestationSignerAuthorized".toLowerCase());

    KStream<String, EventBlock> accountsCreatedStream = builder.stream(accountsTopics,
      Consumed.with(Serdes.String(), eventBlockAvroSerde)
        .withTimestampExtractor(new EventBlockTimestampExtractor()));

    KTable<Windowed<String>, Long> accountsCreatedDayTable =
      accountsCreatedStream
        .selectKey((key, event) -> event.getDetails().getName())
        .groupByKey(Grouped.with(Serdes.String(), eventBlockAvroSerde))
        .windowedBy(new DailyTimeWindows(zone, windowStartHour, gracePeriod))
        // .windowedBy(TimeWindows.of(Duration.ofSeconds(10)))
        .count(Materialized.<String, Long, WindowStore<Bytes, byte[]>>with(Serdes.String(), Serdes.Long())
          // the default store retention time is 1 day;
          // need to explicitly increase the retention time
          // to allow for a 1-day window plus configured grace period
          .withRetention(Duration.ofDays(1L).plus(gracePeriod)))
        // emits the final count when the window is closed.
        .suppress(untilWindowCloses(unbounded()));
    ;

    return formatAccountCreatedAggregation(accountsCreatedDayTable, zone);

  }


  /**
   * Transforms a Windowed Aggregation Table in a Stream of formatted data
   *
   * @param accountsCreatedDayTable
   * @param zone
   * @return
   */
  private KStream<String, AccountCreatedAggregation> formatAccountCreatedAggregation(KTable<Windowed<String>, Long> accountsCreatedDayTable, ZoneId zone) {

    return accountsCreatedDayTable
      .toStream()
      .map((windowed, count) -> {

        AccountCreatedAggregation accountCreatedAggregation = new AccountCreatedAggregation(
          windowed.window().startTime().atZone(zone),
          count,
          windowed.key()

        );

        //DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy - HH:mm:ss Z");
        //String formattedString = windowed.window().startTime().atZone(ZoneOffset.UTC).format(formatter);

        //String key = windowed.key().concat("-").concat(formattedString);

        String key = windowed.key().concat("-").concat(accountCreatedAggregation.getDate());
        return KeyValue.pair(key, accountCreatedAggregation);

      });

  }

  /**
   * @param validatorAffiliated Stream with the events emitted when a validator is affiliated to a validatorGroup
   * @return
   */
  public KTable<Long, Long> validatorPerValidatorGroupAggregation(KStream<String, EventBlock> validatorRegistered, KStream<String, EventBlock> validatorGroupRegistered, KStream<String, EventBlock> validatorAffiliated) {
    List<String> validatorsGroupRegisteredList = listWithValidatorGroupsRegistered(validatorGroupRegistered);
    return validatorAffiliated
      .selectKey((key, event) -> ((StringParameter) event.getDetails().getIndexedParameters().get(1)).getValue())
      .groupByKey()
      .count()
      .filter((k, v) -> validatorsGroupRegisteredList.contains(k))
      .groupBy(new KeyValueMapper<String, Long, KeyValue<Long, Long>>() {
        @Override
        public KeyValue<Long, Long> apply(String s, Long aLong) {
          return new KeyValue(aLong, 0L);
        }
      }, Grouped.with(Serdes.Long(), Serdes.Long()))
      .count()
      ;
  }

  /**
   * Release an alert when there are not new validators in the last 10 minutes.
   *
   * @param builder Stream builder
   * @param validatorRegisteredTopic List with the topic name to subscribe to get the validatorRegistered
   * @param eventBlockAvroSerde Serde for the eventBlock type.
   * @param duration Duration od the window
   */
  public void alertNoNewValidatorsInTime(StreamsBuilder builder, List<String> validatorRegisteredTopic, Serde<EventBlock> eventBlockAvroSerde, Long duration) {
    builder.stream(validatorRegisteredTopic, Consumed.with(Serdes.String(), eventBlockAvroSerde)
      .withTimestampExtractor(new EventBlockTimestampExtractor()))
      .groupByKey()
      .windowedBy(TimeWindows.of(Duration.ofSeconds(duration)).grace(Duration.ofSeconds(duration)))
      .count(Materialized.<String, Long, WindowStore<Bytes, byte[]>>as("count-metric"))
      .suppress(untilWindowCloses(unbounded()))
      .filter((k, v) -> v < 1)
      .toStream()
      .foreach((x, y) -> System.out.println("ERROR, no new validators"));
  }

  private List<String> listWithValidatorGroupsRegistered(KStream<String, EventBlock> validatorGroupRegistered) {
    List<String> zeroValidators = new ArrayList<String>();
    validatorGroupRegistered
      .selectKey((key, event) -> ((StringParameter) event.getDetails().getIndexedParameters().get(0)).getValue())
      .foreach((key, value) -> zeroValidators.add(key));
    return zeroValidators;
  }


}
